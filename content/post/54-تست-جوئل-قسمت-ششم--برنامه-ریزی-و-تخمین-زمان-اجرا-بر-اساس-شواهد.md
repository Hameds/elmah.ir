---
 title: "تست جوئل قسمت ششم: برنامه‌ریزی و تخمین زمان اجرا بر اساس شواهد" 
 date: 2013-09-25T21:02:26+03:30
 draft: false 
 categories: ["Software PM"]
 cover: "/oldimg/26ebs1.png"
---




### تست ششم جوئل: آیا برنامه زمانبندی‌تان به روز است؟



تست ششم جوئل که درباره برنامه زمان‌بنید است، مقدماتی داشت. در دو نوشته درباره [بایدها](/post/46-مقدمه-ای-بر-برنامه-ریزی-برای-تولید-نرم-افزار--بایدها/) و [نبایدها](/post/30-مقدمه-ای-بر-برنامه-ریزی-برای-تولید-نرم-افزار--نبایدها-در-برنامه-ریزی-تولید-نرم-افزار/) در برنامه‌ریزی تولید نرم‌افزار گفتم. به طور خلاصه تست ششم جوئل اشاره می‌کند که یک تیم نرم‌افزاری باید برنامه زمانبندی برای تولید داشته باشد.



یکی از مهمترین دلایلی که جوئل برای داشتن یک برنامه زمانبندی به‌ روز اشاره می‌کند بحث جلوگیری از بیماری featuritis است. بیماری که طراحان و برنامه‌نویسان دچار آن می‌شوند و می‌خواهند به یک سیستم پیچیده امکانات بیشتری را بدون برنامه‌ریزی لازم اضافه کنند. درباره این بیماری در نوشته دیگری مفصل صحبت خواهم کرد، فعلا در پرانتز از تجربه شخصی‌ام در این مورد می‌گویم که محصولی ایجاد کرده بودیم که بر اساس تنظیماتش alert‌های شرطی را به صورت آنی ارسال می‌کرد، برای اینکه از قابلیت‌های این محصول در یک محصول دیگر برای ارسال alert‌ها استفاده کنیم، قابلیت ارسال بر اساس یک زمان‌بندی مشخص (روزانه، هفتگی، ماهیانه) به محصول اضافه شد. نتیجه؟ محصول فوق‌العاده پیچیده شد، دیباگ آن عملاً به یک کابوس تبدیل شد و توسعه آن غیرممکن! برای رهایی از مشکلاتی که اضافه کردن این قابلیت خاص بدون بررسی لازم و پیش‌بینی عواقب آن ایجاد کرده بود، در نسخه بعدی محصول، عملاً قابلیت ارسال بر اساس زمان‌بندی حذف شد!



### چطور یک برنامه ‌ریزی موفق داشته باشیم؟



جوئل در نوشته دیگری به موضوع برنامه‌ریزی می‌پردازد. روش معرفی شده در این نوشته که [Painless Software Schedules](http://www.joelonsoftware.com/articles/fog0000000245.html) نام دارد دیگر قدیمی شده و جوئل [Evidence Based Scheduling](http://www.joelonsoftware.com/items/2007/10/26.html) را پیشنهاد می‌کند.



قبل از صحبت درباره برنامه‌ریزی جوئل به دلایل اینکه برنامه‌نویسان از برنامه‌ریزی تولید نرم‌افزار فرار می‌کند می‌پردازد. مهمترین دلیلی که ذکر می‌شود این است که: "**هیچ کس باور نمی‌کند که برنامه‌ریزی انجام شده واقع‌بینانه باشد!**"



برای کارآمد و واقعی کردن برنامه‌ریزی‌ها، روش Evidence Based Scheduling پیشنهاد می‌شود. در Evidence Based Scheduling شما شواهدی از تاریخچه زمان اجرای کارها را بر اساس لاگ کار برنامه‌نویسان دریافت و آن را به برنامه‌ریزی خودتان اضافه می‌کنید. بر این اساس نموداری از تاریخ‌های احتمالی ارائه کارها یا عرضه محصول ایجاد می‌شود. این نمودار که شکلی شبیه شکل زیر دارد به شما نشان خواهد داد که در چه تاریخی محصول شما عرضه خواهد شد.



![](/oldimg/26ebs1.png)



### Evidence Based Scheduling چطور کار می‌کند؟



برای اینکه یک برنامه‌ریزی موفق با استفاده از روش EBS داشته باشید باید کارهای زیر را انجام دهید:



**1- شکستن زمان انجام وظایف**: برنامه ریزی شما نباید بر اساس روز یا هفته باشد، باید بر اساس ساعت انجام شود، شما باید مجموعه کارهایی که در جریان اجرای یک پروژه باید تکمیل شوند را به وظایفی که حداکثر در 16 ساعت قابل انجام باشند بشکنید.  
مزیت اصلی این کار این است که شما مجبور می‌شوید جزئیات کار را به دقت مشخص کنید. مثلاً اگر قرار باشد یک کار تحت عنوان اضافه کردن پروفایل کاربر داشته باشید و مثلاً برایش 4 روز زمان بگذارید بدون اینکه بدانید عملاً چه کاری می‌خواهد انجام شود، به خاطر همین عدم قطعیت و مشخص نبودن فعالیت‌های اجرایی، در نهایت بیشتر از آن زمان را صرف خواهید کرد و برنامه شما به deadline هایش نخواهد رسید.



**2- زمان صرف شده را ثبت و بررسی کنید**: همه افراد در تخمین زمان اجرای کارها مثل هم نیستند، بعضی دقیق‌تر تخمین می‌زنند و بعضی هم با اختلاف زیاد. نکته مهم این است که زمان تخمین زده شده و زمان واقعی اجرای کارها را ثبت و بر اساس آن نموداری به شکل زیر برای هر برنامه‌نویس آماده کنید.



![](/oldimg/26ebs2.png)



در نمودار بالا، زمان تخمین زده شده و زمان واقعی اجرای کارها نشان داده می‌شود. اینجا یک مفهوم دیگر هم به بازی وارد می‌شود: سرعت اجرای وظایف یا velocity که بر اساس تقسیم زمان تخمین زده شده بر زمان واقعی اجرا به دست می‌آید.



حالت ایده‌آل velocity عدد یک است، یعنی زمان تخمین زده شده و زمان واقعی با هم برابر باشند. در این حالت برنامه نویسی که خوب می‌تواند تخمین بزند، در نمودارش اعداد 1 را برای velocity خواهد داشت. بر حسب میزان تجربه و دقت در تخمین، ممکن است velocity بیشتر یا کمتر از 1 باشد، در نهایت velocity به شما نمایی از میزان دقت در برنامه‌ریزی برای هر شخص در تیم می‌دهد.



**3- شبیه‌سازی آینده:** با استفاده از velocity که در مرحله قبل به دست آوردید می‌توانید زمان تقریبی اتمام کارها را با دقت بالایی تخمین بزنید. در واقع به جای جمع زدن اعداد تخمینی زمان اجرا، از روش زیر برای تخمین زمان استفاده کنید. هر زمانی که برنامه‌نویس برای اجرا به شما اعلام می‌کند در یک velocity تصادفی که از تاریخچه کارهای آن برنامه‌نویس بدست آمده ضرب کنید و به این ترتیب زمان کلی اجرا را بدست آورید، یک نمونه را به شکل زیر می‌توانید مشاهده کنید.



![](/oldimg/26ebs3.png)



**4- پروژه را به صورت فعال مدیریت کنید:** حالا که زمان‌های تخمینی قابل قبول را بدست آوردید به راحتی می‌توانید با پارامترهایی که در اختیار شماست بازی کنید تا نتیجه دلخواهتان را از برنامه ریزی بدست آوردید. مثلاً اگر کارها را بر حسب اولویت مرتب کنید، به راحتی می‌توانید ببینید با حذف کارهای کم اهمیت چقدر در وقت صرفه‌جویی می‌شود و زمان تحویل کار چقدر تفاوت خواهد کرد.



همچنین می‌توانید ببینید وضعیت تحویل کارهای هر برنامه‌نویس چگونه است. خیلی راحت می‌توانید برنامه‌نویسانی که در تخمین زمان اجرا ضعیف عمل کرده‌اند را شناسایی و برای اینکه کارهایشان در زمان مقرر انجام شود فکری بکنید.



درباره روش EBS در مطلب جداگانه‌ای بیشتر صحبت خواهم کرد.

